time: 2024/12/7

确定好了组会要讲的论文，周日读完后开始着手做ppt 阅读+做ppt
学习到CppBaseDay07_3

time: 2024/12/9

/*
   struct与class的区别：默认访问权限
   struct的默认访问权限是共有的public
   class的默认访问权限是私有的private
*/

/*  
   n + shift + k 跳转到函数定义处
*/

学习到CppBaseDay08_1

time: 2024/12/10
学习到CppBaseDay08_2

time: 2025/2/14
回顾了一下之前学过的知识

time: 2025/2/17
不能以对象加点的形式显式调用构造函数
析构函数可以显式调用
可以通过调用构造函数创建临时对象，匿名对象
//Point().print()

学习完CppBaseDay08

time: 2025/2/18
今日任务：学习完CppBaseDay09内容，做两道代码随想录，安装仿真软件

空类也可以创建对象，为了区分空类创造出的不同对象，规定空类的大小为一个字节
单例模式，一个类只能创建一个对象

学习完CppBaseDay09

time: 2025/2/19
今日任务：学习完CppBaseDay10,两道代码随想录，仿真或者算法
完成了CppBaseDay10的homework

学习完CppBaseDay10,后面两个任务没有完成

time: 2025/2/20
完成了3道代码随想录，3easy

time: 2025/2/21
完成了2道代码随想录，2mid

time: 2025/2/22
c++代码面对大量数据读取输出操作时，最好用scanf和printf,耗时相比cin,cout会小很多

完成了2道代码随想录，数组部分完成

time: 2025/2/23
完成了初步仿真，所有值都固定的情况下，得到的结果与预期不符，明天查查错误
完成了一道代码随想录 1easy
还写了一道mid的设计链表的题目，没写对，明天写

time: 2025/2/24
完成了昨天未完成的设计链表的题目 1mid
今天务必把仿真调好，确保论文的ref结果的正确复现
仿真结果始终与论文结果不一致，观察后发现应该是论文公式有问题导致的，需要重新推导公式
晚上完成了一道代码随想录 1easy反转链表 也算是做了一些事情

time: 2025/2/25
论文公式还是没推导，明天看看
今天是新学期第一次组会，每个人讲了讲这学期的规划，当然也有人讲了讲寒假做的事情
完成了3道代码随想录，1easy2mid，无限进步！

time: 2025/2/26
完成了4道代码随想录，3easy1mid,科研上的事情还是没干，明天开始干
继续加油,科研上的事还是要抓紧

time: 2025/2/27
今天还是没做科研上的事情，该推导的公式还没推
完成了两道代码随想录，2easy1mid，继续努力

time: 2025/3/14 
今天完成CppBaseDay11的内容+代码随想录+修改贪心梯度代码

使用explicit来禁止类型隐式转换

time: 2025/3/15
继续完成CppBaseDay11的内容

time: 2025/3/19
学习日志系统

time: 2025/3/20
完成CppBaseDay12的内容
仔细读一下ADMM的论文 看看有什么想法

const类型的类对象只能调用const类型的成员函数，不能调用非const类型的成员函数
而非const类型的类对象const类型和非const类型的成员函数都能调用

time: 2025/3/21
完成了CppBaseDay13的第一个作业   统计单词词频

time: 2025/3/22
完成CppBaseDay13的第二个作业 封装日志类

c++中打印文件名 函数名 行号
c++中有对应的宏
__FILE__ __FUNCTION__ __LINE__

字符串替换的两种方式
内联函数inline 和宏定义 

time: 2025/3/24
整理intro的结构和内容
看看分布式算法
CppBaseDay13
leetcode

对于复合复制运算符，对象本身会发生发生改变的情况，一般都将重载函数设置为
成员函数

time: 2025/4/7
继续之前未完成的CppBaseDay13的内容
进行到输入输出流运算符的重载，完成了相应代码，后面继续学习函数调用运算符的重载

time: 2025/4/9
完成了CppBaseDay13的全部内容以及代码，继续学习！

time: 2025/4/10
安装了ubuntu2204虚拟机，解决了vscode remote ssh 连接不上的问题（ubuntu1804其中的glibc版本未达到要求）

time: 2025/4/11
继续学习CppBaseDay14的内容
隐式转换：从其他类型向自定义类型转换

单例模式：一个类最多只有一个对象
实现方式：
1、构造函数+析构函数私有化
2、静态数据成员：一个指向唯一对象的指针变量 初始化为nullptr
3、静态成员函数：
   getInstance()用来创建唯一的对象
   destroy()用来销毁堆空间

单例模式的自动释放的多种方式：
1、友元类
2、内部类+静态数据成员
3、饿汉模式+atexit
4、pthread_once+atexit

/*碰到的问题*/
/*
vim中的ycm插件(youcompleteme代码补全)报错
未解决问题
替代方法：使用vscode remote ssh连接虚拟机，使用vscode 的代码补全
*/

time: 2025/4/12
继续学习CppBaseDay14的内容，从内部类+静态数据成员开始
/* 关闭vscode所有插件的自动更新，关闭vscode 的自动更新 */

finish the implementation of autorelease of Singleton(4 methods)
tomorrow continue study the implementation of string

time: 2025/4/13
静态成员函数不能调用非静态的数据成员和成员函数
string 的三个历史版本：
1、深拷贝（浅拷贝）
2、写时复制copy on write :只有写的时候使用深拷贝；如果是读操作就直接用浅拷贝。使用的技术：浅拷贝+引用计数
例如ubuntu1404里面使用的就是写时复制
3、短字符串优化（short string optimization）

time: 2025/4/14
继续学习CppBaseDay15的内容
<string.h>中的常用函数：
strcpy/strcat/strcmp/strlen/strncpy
完成了homework部分，完善了昨天cow写时复制代码，解决了不能区分读操作和写操作的问题
CppBaseDay14的内容还剩set 和 map的基本操作，明天完成 然后调研一下其他可以作为对照的集中式算法和分布式算法

time: 2025/4/15
完成了CppBaseDay15的内容
学习了set/map的基本操作

time: 2025/4/16
继续学习CppBaseDay16的内容
学习了继承的相关概念 其中多基继承比较复杂，尤其是其中的菱形继承 主要还是使用单继承
基类与派生类对象间的转换：
1、派生类对象赋值给基类对象 base = derived;
2、基类的引用绑定到派生类对象 Base &base = derived;
3、基类的指针指向派生类的对象 Base *pbase = &derived;
今天没有思考论文相关的内容 明天开始搞

time: 2025/4/17
今天学习完CppBaseDay16的内容

time: 2025/4/20
拖了好几天 主要是在搞那个解析解的问题 但是还是没有解决
今天完成CppBaseDay16的内容，处理掉最后的尾巴
禁止复制的三种方法：
1、将拷贝构造函数和赋值运算符函数设置为private （cpp98）
2、将拷贝构造函数和赋值运算符函数设置为delete (cpp11)
3、设置一个基类，在基类里面将拷贝构造函数和赋值运算符函数设置为delete,然后让子类继承这个基类，并且子类中不去写这两个函数 (cpp98)
完成了CppBaseDay16的内容，但是解析解的问题还没解决！！！

time: 2025/4/21
支委会竞选讲稿记熟
似乎不能写出解析解的显式表达式的形式？
今天学习CppBaseDay17的内容
实现一下对比算法（集中式算法）

**time**: 2025/4/22
支委会竞选现在还未通知，似乎这周没有开会？
找周老师讨论了一下解析解的情况 找不到解析解的显示表达式 那么现在的问题就是如何提高求解速度？
今天继续学习CppBaseDay17的内容 homework部分可以完成 然后再往后继续学习
这周六青年跑 需要提前准备一下 以免受伤

vector容器中reserve函数的作用：
预先分配一定数量的内存空间，以提高在已知所需容量的情况下的性能，减少多次重新分配内存和复制元素的开销

vector<string>中的resize的用法：
resize(num): 将vector的大小调整为num，并且每一个新元素`初始化`为空字符串
比如我之前在2_TextQuery.cc中将reserve(100)写成了resize(100),这样就出现了问题
因为在后面我们是通过vector.push_back()往容器的末尾添加新的元素，所以如果是使用resize(100)来预分配内存空间
就会出现前100个字符串全部为空字符串，我们实际上是在这100个空字符串后面添加新的字符串，所以在程序中输出_file中的字符串都为空
但是如果将resize(100)修改为reserve(100),这样问题就能得到解决，因为reserve只会预分配内存空间，并不会对这些内存空间做相应的初始化

**time**: 2025/4/23
支委会竞选貌似是在下周 或者是在下个月？
继续学习CppBaseDay17的内容  虚函数

**time**: 2025/4/24

继续学习CppBaseDay17的内容

将基类中的虚构函数设置为虚函数，那么派生类中的析构函数会自动变为虚函数，认为其是一种重写
一般建议将基类中的析构函数设置为虚函数

这是c++唯一名字不一样的重写

三个重要的概念：
1、重载: 在同一个作用域内，函数名相同，但是参数列表不同，仅靠返回类型不能区分重载
2、覆盖：在派生类中重写基类中对应的`虚函数`
3、隐藏：在基类和派生类中，函数名相同，是不是虚函数都没有关系 基类与派生类中的数据成员也存在隐藏

虚表的验证
位于只读段 对于普通的单继承而言虚表是唯一的

**time**: 2025/4/25
学习CppBaseDay18的内容
问题回顾：
1、虚函数是成员函数，用virtual 修饰；重写要求派生类中的虚函数与基类中对应的虚函数除函数体外其他都相同
（返回类型，参数列表，函数名）
2、虚函数的原理 动态多态被激活的五个条件
3、哪些函数不能被设置为虚函数？
4、纯虚函数 抽象类的两种形式 抽象类的特点
5、将析构函数设置为虚函数是为了防止内存泄漏 为什么可以将其设置为虚函数？
6、重载 重写 重定义

在基类和派生类中，对于对应的虚函数会存在动态多态的现象，也就是用基类的指针指向或者引用绑定到派生类的对象，然后去调用相应的虚函数，
会出现覆盖（重写）的现象，即会调用派生类中对应的虚函数

但是如果在基类和派生类中只是写了名字相同的普通函数，也就是重定义，那么使用基类的指针指向或者引用绑定到派生类的对象，再去调用相应的
普通函数，那么就只会调用基类里面对应的普通成员函数

**time**: 2025/4/28
学习CppBaseDay19的内容
移动语义函数与拷贝语义函数
具有移动语义的函数优先于拷贝语义的函数执行
非const左值引用不能绑定到右值，只能绑定到左值
右值引用只能绑定到右值，不能绑定到左值
所以拷贝构造函数使用非const左值引用，移动构造函数使用右值引用
移动语义函数的优势：
只进行浅拷贝，减少了复制开销，特别是在处理大型对象或者资源密集型对象时，通过转移资源来避免复制的开销

非const左值引用
const左值引用
右值引用
右值引用是左值还是右值？
当右值引用有名字时，它是一个左值；当右值引用作为函数的返回类型时，它是一个右值

**time**: 2025/5/5
假期结束，继续学习
找一找学习状态 写一写string类

**time**: 2025/5/6
今天晚上组会，明天支委会竞选
熟悉熟悉代码，逐步找学习状态
**熟记竞选发言稿**
值语义： 允许赋值或者复制，具备拷贝构造函数与赋值运算符函数
对象语义： 不允许复制或者赋值，也就是不提供拷贝构造函数和赋值运算符函数
weak_ptr智能指针：弱引用的智能指针，不会增加引用计数
shared_ptr智能指针：强引用的智能指针，共享所有权，会增加引用计数
unique_ptr智能指针：独享所有权的智能指针，不能进行赋值和复制
auto_ptr智能指针：c++ 17已弃用

CppBaseDay19的内容除homework部分全部完成

time: 2025/5/7
继续学习CppBaseDay20的内容

time: 2025/5/8
遇到了一个问题：虚拟机磁盘空间不足
解决方法：
关闭虚拟机
vmware上方-> 电源 -> 打开电源时进入固件
进入boot界面 -> 选中CD-ROM drive -> 使用+升序将CD切到第一个 -> 按F10保存退出 -> 重新进入ubuntu
-> 进入Gparted -> 选中要扩充空间的文件夹 -> 右键点击resize为其扩充空间 -> 关闭虚拟机
-> 继续选中打开电源时进入固件 -> 按F9恢复默认设置，按F10保存退出 -> finish

今天完成intro部分的初版

time: 2025/5/9
今天学习完CppBaseDay20,掌握模板编程 goooooo！！！
完成了CppBaseDay20的学习，还剩一个Day19的homework 学习一个第三方库
后面就都是STL模板库的内容，过起来应该会比较快   还要抽时间学习一下git代码版本管理

time：2025/5/10

学习latex

继续学习CppBaseDay21的内容
